<style type="text/css">
  * { margin:0; padding:0; } /* to remove the top and left whitespace */
  html, body { width:100%; height:100%; } /* just to be sure these are full screen*/
  canvas { display:block; } /* To remove the scrollbars */
</style>
<div>
  <canvas id="lifeCanvas" width="500" height="500"></canvas>
</div>
<script type="text/javascript">
  "use strict";

  const BRICK_W = 50;
  const BRICK_H = 10;
  const BRICK_GAP = 1;
  const BRICK_COLS = 10;
  const BRICK_ROWS = 15;
  var brickGrid = new Array(BRICK_COLS * BRICK_ROWS);
  var brickScores = new Array(BRICK_COLS * BRICK_ROWS);
  var change = 1;
  var ratio = 1;
  var scalex = 1;
  var scaley = 1;
  var filledscreen = false;
  const PADDLE_WIDTH = 80;
  const PADDLE_THICKNESS = 5;
  const PADDLE_DIST_FROM_EDGE = 20;
  var bricksLeft = 0;
  var canvas = document.getElementById('lifeCanvas'); // Get the canvas reference from DOM
  var canvasContext = canvas.getContext('2d'); // Get the canvas context
  var paddleX = 100;
  var paddleY = canvas.height - PADDLE_DIST_FROM_EDGE;
  var mouseX = 0;
  var mouseY = 0;
  var life = 0;
  var eachCol; 
  var eachRow;
  var i;
  var f;
  var arrayIndex;
  var fullcanvas;
  var ballX = 100;
  var ballSpeedX = 5;
  var ballY = 100;
  var ballSpeedY = 8;
  var introtime = 0;
  var level = 0;
  var lives = 6;
  var lost = false;
  var gradient=canvasContext.createLinearGradient(0,0,canvas.width,canvas.height);
    gradient.addColorStop("0.1","magenta");
    gradient.addColorStop("0.3","blue");
    gradient.addColorStop("0.7","red");
  
 
  document.addEventListener("turbolinks:load", function() { //Document Ready specified for turbolinks - Needed to fire correctly in Rails 5.0 envoironment
  });// End of Document Ready Turbolinks enclosure

  
  

  canvas.addEventListener('mousemove', updateMousePos, false); // listen for mousemovement
  window.addEventListener('click', function(e) { // listen for clicks         
    updateMousePos(e);
    fullscreen();  // single fire version of fullscreen added to click      
  }, false);
  window.addEventListener('touchstart', function(e) { // listen for touches           
    updateMousePos(e.touches[0]);
  }, false);
  window.addEventListener('touchmove', function(e) {
    updateMousePos(e.touches[0]);
    e.preventDefault(); // no zoom or scroll
  }, false);
  window.addEventListener('touchend', function(e) {
    updateMousePos(e.touches[0]);
    e.preventDefault(); // no zoom or scroll
  }, false);

  var flip = document.getElementsByClassName("canvasflip"); // Get rid of the BootStrap menu 
  for (f = 0; f < flip.length; f += 1) {
    flip[f].outerHTML = ""; // Empty all elements in array
  }

  var framesPerSecond = 20;
  setInterval(updateAll, 1000/framesPerSecond); // Set the timer
  brickReset();// Initial Random Map


  function gradientChange() { // Needs Refactoring for More level progression
    if(level === 1) {  // For each level, cycle a gradient
      setGradient("aqua", "blueviolet", "chartreuse");
    }
    else if (level === 2) {
      setGradient("blueviolet", "chartreuse", "coral");
    }
    else if (level === 3) {
      setGradient("chartreuse","coral","cyan");
    }
    else if (level === 4) {
      setGradient("coral","cyan","darkorange");
    }
    else if (level === 5) {
      setGradient("cyan","darkorange","fuchsia");
    }
    else if (level === 6) {
      setGradient("darkorange","fuchsia","greenyellow");
    }
    else {
      setGradient("gold","gold","gold");
    }

  }

  function setGradient(color1, color2, color3) { // Empties the gradient and sets a new one with 3 color inputs
    gradient = null;  // Kill the previous gradient
    gradient=canvasContext.createLinearGradient(0,0,canvas.width,canvas.height); // Set a new one for our canvas
    gradient.addColorStop("0",color1); // add all 3 colors
    gradient.addColorStop("0.3",color2);
    gradient.addColorStop("0.7",color3);
  }

  function updateAll() { // General Functions
    if (introtime <= 100) {
      
      introtime += 1;
    }
    else {
      moveAll(); // Apply movement to entities

    }
    
    resize(); // Check canvas size - if not a match resize
    
    brickBallCollision(); // Handle Ball/BrickCollision
    drawAll(); // Update the screen
  }
 
  function moveAll() {
    ballX += ballSpeedX;
    ballY += ballSpeedY;

    if(ballX < 0 && ballSpeedX < 0.0) { // Left
      ballSpeedX *= -1;
    }

    if(ballX > canvas.width  && ballSpeedX > 0.0) { // Right
      ballSpeedX *= -1;
    }

    if(ballY < 0 && ballSpeedY < 0.0) { // Top
      ballSpeedY *= -1;
    }

    if(ballY > (canvas.height + 150) ){ // bottom
      
      ballReset(); // if goes off bottom, reset ball
      lives -= 1;  // Remove a life
      if(lives === 0) { // If that was the last one
        lost = true; // The Player has lost
      }
      // ballSpeedY *= -1; // Direction reversal
      
    }
   
    var paddleTopEdgeY = canvas.height - PADDLE_DIST_FROM_EDGE;
    var paddleBottomEdgeY = paddleTopEdgeY + PADDLE_THICKNESS;
    var paddleLeftEdgeX = paddleX;
    var paddleRightEdgeX = paddleLeftEdgeX + PADDLE_WIDTH;

    if (ballY > paddleTopEdgeY && // Below top of paddle
        ballY < paddleBottomEdgeY && // above the bottom
        ballX > paddleLeftEdgeX && // right of left side
        ballX < paddleRightEdgeX) { // left of right side
      ballSpeedY *= -1;

      var centerOfPaddleX = paddleX + PADDLE_WIDTH/2;
      var ballDistFromPaddleCenterX = ballX - centerOfPaddleX;
      ballSpeedX = ballDistFromPaddleCenterX * 0.35;

      if(bricksLeft === 0) {
        brickReset();
      }
    }
  }

  function drawAll() {
    colorRect(0,0, canvas.width,canvas.height, 'black'); // clear screen
    colorRect(paddleX, paddleY, PADDLE_WIDTH,PADDLE_THICKNESS, 'gold');// Draw Paddle
    drawBricks();
    //colorText(Math.floor(mouseX/scalex)+","+Math.floor(mouseY/scaley), mouseX/scalex,mouseY/scaley, 'yellow');// Draw Debug Paddle Text
    
    if (introtime <= 100) {
      var lessintrotime = 100 - introtime
      colorTextFancy("Get Ready " + lessintrotime, 100,400,gradient);// Draw Debug Paddle Text
    }
    else{
      if(lost){ // If the player lose conditions are true
        colorTextFancy("GAME OVER", 190,300,gradient);// Show Game Over Screen text
        gradient = null; // Kill the gradient variable
        setGradient("grey","grey","grey"); // and set a new gradient for all grey
        
      }
      else { // If the player hasn't lost yet
        
        colorTextFancy("Bricks "+bricksLeft, 10,20,gradient);// Draw Bricks Menu
        colorTextFancy("Level "+level, 400,20,gradient);// Draw Level Menu
        colorTextFancy("Lives "+lives, 200,20,gradient);// Draw Lives Menu
        // colorTextFancy("Bit's Brick Game - More Lives Added", 100,400,gradient);// Bits Message
        colorCircle(ballX,ballY, 5, "White"); // Draw the Ball
      }
    }
  }

  function isBrickAtColRow(col,row) { // Is this a valid brick in our grid?
    if(col >= 0 && col < BRICK_COLS && // if is matches our defined constants for grid size
       row >= 0 && row < BRICK_ROWS) {
      var brickIndexUnderCoord = rowColToArrayIndex(col, row); // compute the Index
      return brickGrid[brickIndexUnderCoord]; // Return our index for the array
    } else {
      return false; // if its not in our grid, return false
    }
  }

  function brickBallCollision() { // Handle results of ball/Brick position overlap
    var ballBrickCol = Math.floor(ballX / BRICK_W); // Round values to save processor cycles
    var ballBrickRow = Math.floor(ballY / BRICK_H); // When computing where the ball is on the grid
    var brickIndexUnderBall = rowColToArrayIndex(ballBrickCol, ballBrickRow); // brickIndexUnderBall is true if Index is matched
    
    if(ballBrickCol >= 0 && ballBrickCol < BRICK_COLS &&
       ballBrickRow >= 0 && ballBrickRow < BRICK_ROWS) { // And if the ball is on a spot on the grid that holds a brick
      
      if(isBrickAtColRow(ballBrickCol,ballBrickRow)) {
        brickGrid[brickIndexUnderBall] = false; // Mark that brick to be deleted
        bricksLeft--; // Reduce the Bricks left for the Display Counter


        var prevBallX = ballX - ballSpeedX; // Ask the Question: Where was the ball in the last frame?
        var prevBallY = ballY - ballSpeedY;
        var prevBrickCol = Math.floor(prevBallX / BRICK_W); // Round the value and calculate which 
        var prevBrickRow = Math.floor(prevBallY / BRICK_H); // Column and row that corresponds to

        var bothTestsFailed = true; // Means it hit a corner

        if(prevBrickCol != ballBrickCol) { // if the hit came from a different Column
          if(isBrickAtColRow(prevBrickCol, ballBrickRow) === false) { // and if it's a valid brick
            ballSpeedX *= -1; // Bounce the ball on the x axis
            bothTestsFailed = false; // This was not a corner
          }
          
        }
        if(prevBrickRow != ballBrickRow) { // if the hit came from a differet Row
          if(isBrickAtColRow(ballBrickCol, prevBrickRow) === false) { // and if it's a valid brick
            ballSpeedY *= -1; // Bounce the ball on the y axis
            bothTestsFailed = false; // This was not a corner
          }
          
        }

        if(bothTestsFailed) { // This must be a corner
          ballSpeedX *= -1; // bounce the ball on both axises
          ballSpeedY *= -1;
        }
      }      
    }
  }

  function drawBricks() { // Draws the bricks for every frame
    for(eachRow=0;eachRow<BRICK_ROWS;eachRow += 1) { // For Each Column
      for(eachCol=0;eachCol<BRICK_COLS;eachCol += 1) { // And Each Row
        arrayIndex = rowColToArrayIndex(eachCol, eachRow); // Compute the Index
        if(brickGrid[arrayIndex]) { // And if that index reads true
          colorRect(BRICK_W*eachCol,BRICK_H*eachRow, BRICK_W-BRICK_GAP,BRICK_H-BRICK_GAP, gradient); // Draw a Blue square
        }
      }
    }
  }

  function updateMousePos(evt) {
    var rect = canvas.getBoundingClientRect(); // Get the size of the canvas
    var root = document.documentElement; // Get the document root from the DOM
    mouseX = evt.clientX - rect.left - root.scrollLeft; // Get the origin for the Left
    mouseY = evt.clientY - rect.top - root.scrollTop; // and top sides of the screen
    paddleX = mouseX / scalex - PADDLE_WIDTH/2; // Place the paddle on screen after factoring the scale
    // paddleY = mouseY / scaley - PADDLE_THICKNESS/2;
  }

  function brickReset() {
    bricksLeft = 0;
    for(i=0;i < 3*BRICK_COLS;i += 1) { // for all of the columns in all the rows
        brickGrid[i] = false;
    }
    for(;i<BRICK_COLS * BRICK_ROWS;i += 1) { // for all of the columns in all the rows
        brickGrid[i] = true;
        bricksLeft++;
    }
    level +=1;
    ballReset(); // Reset the Ball into play
    gradientChange(); // Change the Brick and Text Color
    
  }

  function ballReset() { // Reset the Ball Position only
    ballX = canvas.width/2;
    ballY = canvas.height/2;
  }

  function rowColToArrayIndex(col, row) { // calculate the index within the column array based on position
    return col + BRICK_COLS * row;
  }

  function colorRect(topLeftX,topLeftY, boxWidth,boxHeight, fillColor) { // General canvas Rectangle function
    canvasContext.fillStyle = fillColor;
    canvasContext.fillRect(topLeftX,topLeftY, boxWidth,boxHeight);
  }

  function colorCircle(centerX,centerY, radius, fillColor) { // General canvas Circle function
    canvasContext.fillStyle = fillColor;
    canvasContext.beginPath();
    canvasContext.arc(centerX,centerY, radius, 0,Math.PI*2, true);
    canvasContext.fill();
  }

  function colorText(showWords, textX,textY, fillColor) { // General canvas Text function
    canvasContext.fillStyle = fillColor;
    canvasContext.fillText(showWords, textX,textY);
  }

  function colorTextFancy(showWords, textX,textY, fillColor) { // 20px Verdana canvas Text function
    canvasContext.font="20px Verdana";
    canvasContext.fillStyle=fillColor;
    canvasContext.fillText(showWords, textX,textY);
  }

  function resize() { // resizes the canvas to the window width and height
    if (canvas.currentHeight !== window.innerHeight || canvas.currentWidth !== window.innerWidth) { // If we're not already perfectly sized for width and height
      canvas.currentHeight = window.innerHeight; // Size us with the height first
      ratio = window.innerWidth / window.innerHeight; // Then compute the aspect ratio of the window
      
      canvas.currentWidth = canvas.currentHeight * ratio; // And resize the width to that ratio
      scalex = canvas.currentWidth / canvas.width; // Our scale can now be computed based upon the original width
      scaley = canvas.currentHeight / canvas.width; // And height of the canvas vs it's new size, which we'll need for correct input
      canvas.style.width = canvas.currentWidth + 'px'; // scale the canvas with CSS
      canvas.style.height = canvas.currentHeight + 'px';
    }
  }

  function fullscreen(){ // Requests FullScreen from the browser on the first click
    if(filledscreen === false) { // If we haven't tried this before
     if(canvas.webkitRequestFullScreen) { // And if this is Chrome or Safari
         canvas.webkitRequestFullScreen(); // Go for the webkit fullscreen Request
     }
    else {
       canvas.mozRequestFullScreen(); // Else we'll try the Mozilla fullscreen Request
    }     
    filledscreen = true;  // Now we've tried this once.
    }              
  }

</script>