<style type="text/css">
  * { margin:0; padding:0; } /* to remove the top and left whitespace */
  html, body { width:100%; height:100%; } /* just to be sure these are full screen*/
  canvas { display:block; } /* To remove the scrollbars */
</style>
<div>
  <canvas id="lifeCanvas" width="500" height="500"></canvas>
</div>
<script type="text/javascript">
  "use strict";

  const BRICK_W = 50;
  const BRICK_H = 16;
  const BRICK_GAP = 1;
  const BRICK_COLS = 10;
  const BRICK_ROWS = 9;
  var gutter = 3;
  var brickGrid = new Array(BRICK_COLS * BRICK_ROWS);
  var brickScores = new Array(BRICK_COLS * BRICK_ROWS);
  var change = 1;
  var ratio = 1;
  var scalex = 1;
  var scaley = 1;
  var filledscreen = false;
  const PADDLE_WIDTH = 80;
  const PADDLE_THICKNESS = 8;
  const PADDLE_DIST_FROM_EDGE = 20;
  var ballSize = 5;
  var bricksLeft = 0;
  var canvas = document.getElementById('lifeCanvas'); // Get the canvas reference from DOM
  var canvasContext = canvas.getContext('2d'); // Get the canvas context
  var paddleX = 100;
  var paddleY = canvas.height - PADDLE_DIST_FROM_EDGE;
  var mouseX = 0;
  var mouseY = 0;
  var life = 0;
  var eachCol; 
  var eachRow;
  var i;
  var f;
  var arrayIndex;
  var fullcanvas;
  var ballX = 100;
  var ballSpeedX = 2;
  var ballY = 100;
  var ballSpeedY = 5;
  var pointIndex;
  var introtime = 0;
  var level = 0;
  var lives = 99;
  var lost = false;
  var held = false;
  var touchActive;

  var gradient=canvasContext.createLinearGradient(0,0,canvas.width,canvas.height);
    gradient.addColorStop("0.1","magenta");
    gradient.addColorStop("0.3","blue");
    gradient.addColorStop("0.7","red");
  
 
  document.addEventListener("turbolinks:load", function() { //Document Ready specified for turbolinks - Needed to fire correctly in Rails 5.0 envoironment
  });// End of Document Ready Turbolinks enclosure

  
  

  canvas.addEventListener('mousemove', updateMousePos, false); // listen for mousemovement
  canvas.addEventListener('mousedown', function() {
    touchActive = true;
  }, false); // listen for mousedown
  canvas.addEventListener('mouseup', function() {
    touchActive = false;
    held = false;
  }, false); // listen for mouseup
  window.addEventListener('click', function(e) { // listen for clicks         
    updateMousePos(e);
    fullscreen();  // single fire version of fullscreen added to click      
  }, false);
  window.addEventListener('touchstart', function(e) { // listen for touches 
    touchActive = true;
    updateMousePos(e.touches[0]);
  }, false);
  window.addEventListener('touchmove', function(e) {
    touchActive = true;
    updateMousePos(e.touches[0]);
    e.preventDefault(); // no zoom or scroll
  }, false);
  window.addEventListener('touchend', function(e) {
    touchActive = false;
    held = false;
    updateMousePos(e.touches[0]);
    e.preventDefault(); // no zoom or scroll
  }, false);

  var flip = document.getElementsByClassName("canvasflip"); // Get rid of the BootStrap menu 
  for (f = 0; f < flip.length; f += 1) {
    flip[f].outerHTML = ""; // Empty all elements in array
  }

  var framesPerSecond = 30;
  setInterval(updateAll, 1000/framesPerSecond); // Set the timer
  brickReset();// Initial Random Map


  function gradientChange() { // Needs Refactoring for More level progression
    if(level === 1) {  // For each level, cycle a gradient
      setGradient("aqua", "blueviolet", "chartreuse");
    }
    else if (level === 2) {
      setGradient("blueviolet", "chartreuse", "coral");
    }
    else if (level === 3) {
      setGradient("chartreuse","coral","cyan");
    }
    else if (level === 4) {
      setGradient("coral","cyan","darkorange");
    }
    else if (level === 5) {
      setGradient("cyan","darkorange","fuchsia");
    }
    else if (level === 6) {
      setGradient("darkorange","fuchsia","greenyellow");
    }
    else {
      setGradient("gold","gold","gold");
    }

  }

  function setGradient(color1, color2, color3) { // Empties the gradient and sets a new one with 3 color inputs
    gradient = null;  // Kill the previous gradient
    gradient=canvasContext.createLinearGradient(0,0,canvas.width,canvas.height); // Set a new one for our canvas
    gradient.addColorStop("0",color1); // add all 3 colors
    gradient.addColorStop("0.3",color2);
    gradient.addColorStop("0.7",color3);
  }

  function updateAll() { // General Functions
    if (introtime <= 50) {
      
      introtime += 1;
    }
    else {
      moveAll(); // Apply movement to entities

    }
    
    resize(); // Check canvas size - if not a match resize
    
    brickBallCollision(); // Handle Ball/BrickCollision
    drawAll(); // Update the screen
  }
 
  function moveAll() {
    if(held === false) {
      ballX += ballSpeedX;
      ballY += ballSpeedY;

      if(ballX < 0 && ballSpeedX < 0.0) { // Left
        ballSpeedX *= -1;
      }

      if(ballX > canvas.width  && ballSpeedX > 0.0) { // Right
        ballSpeedX *= -1;
      }

      if(ballY < 0 && ballSpeedY < 0.0) { // Top
        ballSpeedY *= -1;
      }

      if(ballY > (canvas.height + 150) ){ // bottom
        
        ballReset(); // if goes off bottom, reset ball
        lives -= 1;  // Remove a life
        if(lives === 0) { // If that was the last one
          lost = true; // The Player has lost
        }
        // ballSpeedY *= -1; // Direction reversal
        
      }
     
      var paddleTopEdgeY = canvas.height - PADDLE_DIST_FROM_EDGE;
      var paddleBottomEdgeY = paddleTopEdgeY + PADDLE_THICKNESS;
      var paddleLeftEdgeX = paddleX;
      var paddleRightEdgeX = paddleLeftEdgeX + PADDLE_WIDTH;

      if (ballY > paddleTopEdgeY - ballSize && // Below top of paddle - ball size
          ballY < paddleBottomEdgeY && // above the bottom
          ballX > paddleLeftEdgeX && // right of left side
          ballX < paddleRightEdgeX) { // left of right side
        if(held === false && touchActive === true) {
          held = true;
        }
        else {
          ballSpeedY *= -1;

          var centerOfPaddleX = paddleX + PADDLE_WIDTH/2; // compute what the center of the player paddle is
          var ballDistFromPaddleCenterX = ballX - centerOfPaddleX; // compute the distance from center the ball hit the paddle
          ballSpeedX = ballDistFromPaddleCenterX * 0.25; // Left/Right speed of ball is determined by distance from center with 1/3 modifier

          if(bricksLeft === 0) { // If that was the last brick in the Grid
            brickReset(); // Reset the level/Grid
          }
        }
        
      }
    }
    else {
      ballX = paddleX + PADDLE_WIDTH / 2;
      ballY = paddleY - ballSize;
      ballSpeedY *= -1;

    }
    

    
  }

  function drawAll() {
    colorRect(0,0, canvas.width,canvas.height, 'black'); // clear screen
    colorRect(paddleX, paddleY, PADDLE_WIDTH,PADDLE_THICKNESS, 'gold');// Draw Paddle
    drawBricks();
    //colorText(Math.floor(mouseX/scalex)+","+Math.floor(mouseY/scaley), mouseX/scalex,mouseY/scaley, 'yellow');// Draw Debug Paddle Text
    
    if (introtime <= 50) {
      var lessintrotime = 50 - introtime
      colorTextFancy("Get Ready " + lessintrotime, 100,400,gradient);// Draw Debug Paddle Text
    }
    else{
      if(lost){ // If the player lose conditions are true
        colorTextFancy("GAME OVER", 190,300,gradient);// Show Game Over Screen text
        gradient = null; // Kill the gradient variable
        setGradient("grey","grey","grey"); // and set a new gradient for all grey
        
      }
      else { // If the player hasn't lost yet
        
        colorTextFancy("Bricks "+bricksLeft, 10,20,gradient);// Draw Bricks Menu
        colorTextFancy("Level "+level, 280,20,gradient);// Draw Level Menu
        colorTextFancy("Lives "+lives, 160,20,gradient);// Draw Lives Menu
        colorTextFancy("Version .5", 380,20,gradient);// Draw Lives Menu
        // colorTextFancy("Bit's Brick Game - More Lives Added", 100,400,gradient);// Bits Message
        colorCircle(ballX,ballY, ballSize, "White"); // Draw the Ball
      }
    }
  }

  

  function brickBallCollision() { // Handle results of ball/Brick position overlap

    // ---- BRICK DECTECTION/HANDLING

    // isPointOverBrick(ballLeftSide) && isPointOverBrick(ballRightSide) && isPointOverBrick(ballTopSide) && isPointOverBrick(ballBottomSide)

    if (isPointOverBrick(ballLeftSide) && isPointOverBrick(ballRightSide) && isPointOverBrick(ballTopSide) && isPointOverBrick(ballBottomSide)) {
      var ballBrickCol = Math.floor(ballX / BRICK_W); // Round values to save processor cycles
      var ballBrickRow = Math.floor(ballY / BRICK_H); // When computing where the ball center is on the grid
      var brickIndexUnderBall = rowColToArrayIndex(ballBrickCol, ballBrickRow); // Calculate whate the brickGrid Index would be
      
      if(ballBrickCol >= 0 && ballBrickCol < BRICK_COLS &&
         ballBrickRow >= 0 && ballBrickRow < BRICK_ROWS) { //==== And if the ball center is on a spot on the grid that holds a brick
        
        if(isBrickAtColRow(ballBrickCol,ballBrickRow)) { // if it's an active brick
          brickGrid[brickIndexUnderBall] = false; // Mark that brick to be deleted
          bricksLeft--; // Reduce the Bricks left for the Display Counter

          // ---- BOUNCE CODE


          var prevBallX = ballX - ballSpeedX; // Ask the Question: Where was the ball in the last frame?
          var prevBallY = ballY - ballSpeedY;
          var prevBrickCol = Math.floor(prevBallX / BRICK_W); // Round the value and calculate which 
          var prevBrickRow = Math.floor(prevBallY / BRICK_H); // Column and row that corresponds to

          var bothTestsFailed = true; // Means it hit a corner

          if(prevBrickCol != ballBrickCol) { // if the hit came from a different Column
            if(isBrickAtColRow(prevBrickCol, ballBrickRow) === false) { // and if it's a valid brick
              ballSpeedX *= -1; // Bounce the ball on the x axis
              bothTestsFailed = false; // This was not a corner
            }
            
          }
          if(prevBrickRow != ballBrickRow) { // if the hit came from a differet Row
            if(isBrickAtColRow(ballBrickCol, prevBrickRow) === false) { // and if it's a valid brick
              ballSpeedY *= -1; // Bounce the ball on the y axis
              bothTestsFailed = false; // This was not a corner
            }
            
          }

          if(bothTestsFailed) { // This must be a corner
            ballSpeedX *= -1; // bounce the ball on both axises
            ballSpeedY *= -1;
          }
        }      
      }

    }
    else {
      var ballLeftSide = (ballX - ballSize); // Left Edge of Ball
      var ballRightSide = (ballX + ballSize); // Right Edge of Ball
      var ballBottomSide = (ballY + ballSize); // Bottom of Ball
      var ballTopSide = (ballY - ballSize); // Top of Ball


      if(ballSpeedX > 0 && isPointOverBrick(ballRightSide, ballY)) { // if it's going right and it's right edge is over a brick
        pointIndex = isPointOverBrick(ballRightSide, ballY);
        killBrick(false);
      }

      if(ballSpeedX < 0 && isPointOverBrick(ballLeftSide, ballY)) { // if it's going right and it's right edge is over a brick
        pointIndex = isPointOverBrick(ballLeftSide, ballY);
        killBrick(false);
      }

      if(ballSpeedY > 0 && isPointOverBrick(ballX, ballBottomSide)) { // if it's going down and it's bottom edge is over a brick
        pointIndex = isPointOverBrick(ballX, ballBottomSide);
        killBrick(true);
      }

      if(ballSpeedY < 0 && isPointOverBrick(ballX, ballTopSide) ) {  // if the ball is going up and it's top edge is over a brick or 
        pointIndex = isPointOverBrick(ballX, ballTopSide);
        killBrick(true);
      }
    }
  }

  function isPointOverBrick(xcoord,ycoord) { // compute if a point is on a valid active brick
    var pointBrickCol = Math.floor(xcoord / BRICK_W); // Round values to save processor cycles
    var pointBrickRow = Math.floor(ycoord / BRICK_H); // When computing where the point is on the grid
    var pointIndexUnderBall = rowColToArrayIndex(pointBrickCol, pointBrickRow); // Calculate whate the brickGrid Index would be

    if(pointBrickCol >= 0 && pointBrickCol < BRICK_COLS &&
       pointBrickRow >= 0 && pointBrickRow < BRICK_ROWS) { //==== And if the point center is on a spot on the grid that holds a brick
      if(isBrickAtColRow(pointBrickCol,pointBrickRow)) { // if it's an active brick
        return pointIndexUnderBall;
      }
      else {
        return false;
      }
    }
  }

  function isBrickAtColRow(col,row) { // Is this a valid brick in our grid?
    if(col >= 0 && col < BRICK_COLS && // if is matches our defined constants for grid size
       row >= 0 && row < BRICK_ROWS) {
      var brickIndexUnderCoord = rowColToArrayIndex(col, row); // compute the Index
      return brickGrid[brickIndexUnderCoord]; // Return our index for the array
    } else {
      return false; // if its not in our grid, return false
    }
  }

  function rowColToArrayIndex(col, row) { // calculate the index within the column array based on position
    return col + BRICK_COLS * row;
  }





  function killBrick(vertical) {
    brickGrid[pointIndex] = false; // Mark that brick to be deleted
    bricksLeft--; // Reduce the Bricks left for the Display Counter
    if(vertical) {
      ballSpeedY *= -1; // Reverse vertical ball speed
    }
    else {
      ballSpeedX *= -1; // Reverse horizontal ball speed
    }
  }


  



  function drawBricks() { // Draws the bricks for every frame
    for(eachRow=0;eachRow<BRICK_ROWS;eachRow += 1) { // For Each Column
      for(eachCol=0;eachCol<BRICK_COLS;eachCol += 1) { // And Each Row
        arrayIndex = rowColToArrayIndex(eachCol, eachRow); // Compute the Index
        if(brickGrid[arrayIndex]) { // And if that index reads true
          colorRect(BRICK_W*eachCol,BRICK_H*eachRow, BRICK_W-BRICK_GAP,BRICK_H-BRICK_GAP, gradient); // Draw a Blue square
        }
      }
    }
  }

  function updateMousePos(evt) {
    var rect = canvas.getBoundingClientRect(); // Get the size of the canvas
    var root = document.documentElement; // Get the document root from the DOM
    mouseX = evt.clientX - rect.left - root.scrollLeft; // Get the origin for the Left
    mouseY = evt.clientY - rect.top - root.scrollTop; // and top sides of the screen
    paddleX = mouseX / scalex - PADDLE_WIDTH/2; // Place the paddle on screen after factoring the scale
    // paddleY = mouseY / scaley - PADDLE_THICKNESS/2;
  }

  function brickReset() {
    bricksLeft = 0;
    for(i=0;i < gutter * BRICK_COLS;i += 1) { // for all of the columns in all the rows
        brickGrid[i] = false;
    }
    for(;i<BRICK_COLS * BRICK_ROWS;i += 1) { // for all of the columns in all the rows
        brickGrid[i] = true;
        bricksLeft++;
    }
    level +=1;
    ballReset(); // Reset the Ball into play
    gradientChange(); // Change the Brick and Text Color
    
  }

  function ballReset() { // Reset the Ball Position only
    ballX = canvas.width/2;
    ballY = canvas.height/2;
  }



  function colorRect(topLeftX,topLeftY, boxWidth,boxHeight, fillColor) { // General canvas Rectangle function
    canvasContext.fillStyle = fillColor;
    canvasContext.fillRect(topLeftX,topLeftY, boxWidth,boxHeight);
  }

  function colorCircle(centerX,centerY, radius, fillColor) { // General canvas Circle function
    canvasContext.fillStyle = fillColor;
    canvasContext.beginPath();
    canvasContext.arc(centerX,centerY, radius, 0,Math.PI*2, true);
    canvasContext.fill();
  }

  function colorText(showWords, textX,textY, fillColor) { // General canvas Text function
    canvasContext.fillStyle = fillColor;
    canvasContext.fillText(showWords, textX,textY);
  }

  function colorTextFancy(showWords, textX,textY, fillColor) { // 20px Verdana canvas Text function
    canvasContext.font="20px Verdana";
    canvasContext.fillStyle=fillColor;
    canvasContext.fillText(showWords, textX,textY);
  }

  function resize() { // resizes the canvas to the window width and height
    if (canvas.currentHeight !== window.innerHeight || canvas.currentWidth !== window.innerWidth) { // If we're not already perfectly sized for width and height
      canvas.currentHeight = window.innerHeight; // Size us with the height first
      ratio = window.innerWidth / window.innerHeight; // Then compute the aspect ratio of the window
      
      canvas.currentWidth = canvas.currentHeight * ratio; // And resize the width to that ratio
      scalex = canvas.currentWidth / canvas.width; // Our scale can now be computed based upon the original width
      scaley = canvas.currentHeight / canvas.width; // And height of the canvas vs it's new size, which we'll need for correct input
      canvas.style.width = canvas.currentWidth + 'px'; // scale the canvas with CSS
      canvas.style.height = canvas.currentHeight + 'px';
    }
  }

  function fullscreen(){ // Requests FullScreen from the browser on the first click
    if(filledscreen === false) { // If we haven't tried this before
     if(canvas.webkitRequestFullScreen) { // And if this is Chrome or Safari
         canvas.webkitRequestFullScreen(); // Go for the webkit fullscreen Request
     }
    else {
       canvas.mozRequestFullScreen(); // Else we'll try the Mozilla fullscreen Request
    }     
    filledscreen = true;  // Now we've tried this once.
    }              
  }

</script>