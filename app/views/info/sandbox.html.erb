<style type="text/css">
  * { margin:0; padding:0; } /* to remove the top and left whitespace */
  html, body { width:100%; height:100%; } /* just to be sure these are full screen*/
  canvas { display:block; } /* To remove the scrollbars */
</style>
<div>
  <canvas id="lifeCanvas" width="500" height="500"></canvas>
</div>
<script type="text/javascript">
  "use strict";

  const BRICK_W = 50;
  const BRICK_H = 10;
  const BRICK_GAP = 1;
  const BRICK_COLS = 10;
  const BRICK_ROWS = 15;
  var brickGrid = new Array(BRICK_COLS * BRICK_ROWS);
  var brickScores = new Array(BRICK_COLS * BRICK_ROWS);
  var change = 1;
  var ratio = 1;
  var scalex = 1;
  var scaley = 1;
  var filledscreen = false;
  const PADDLE_WIDTH = 80;
  const PADDLE_THICKNESS = 5;
  const PADDLE_DIST_FROM_EDGE = 20;
  var bricksLeft = 0;
  var canvas = document.getElementById('lifeCanvas'); // Get the canvas reference from DOM
  var canvasContext = canvas.getContext('2d'); // Get the canvas context
  var paddleX = 100;
  var paddleY = canvas.height - PADDLE_DIST_FROM_EDGE;
  var mouseX = 0;
  var mouseY = 0;
  var life = 0;
  var eachCol; 
  var eachRow;
  var i;
  var f;
  var arrayIndex;
  var fullcanvas;
  var ballX = 100;
  var ballSpeedX = 5;
  var ballY = 100;
  var ballSpeedY = 8;
  var introtime = 0;
  
 
  document.addEventListener("turbolinks:load", function() { //Document Ready specified for turbolinks - Needed to fire correctly in Rails 5.0 envoironment
  });// End of Document Ready Turbolinks enclosure

  
  var gradient=canvasContext.createLinearGradient(0,0,canvas.width,0);
    gradient.addColorStop("0","magenta");
    gradient.addColorStop("0.5","blue");
    gradient.addColorStop("1.0","red");

  canvas.addEventListener('mousemove', updateMousePos, false); // listen for mousemovement
  window.addEventListener('click', function(e) { // listen for clicks         
    updateMousePos(e);
    fullscreen();  // single fire version of fullscreen added to click      
  }, false);
  window.addEventListener('touchstart', function(e) { // listen for touches           
    updateMousePos(e.touches[0]);
  }, false);
  window.addEventListener('touchmove', function(e) {
    updateMousePos(e.touches[0]);
    e.preventDefault(); // no zoom or scroll
  }, false);
  window.addEventListener('touchend', function(e) {
    updateMousePos(e.touches[0]);
    e.preventDefault(); // no zoom or scroll
  }, false);

  var flip = document.getElementsByClassName("canvasflip"); // Get rid of the BootStrap menu 
  for (f = 0; f < flip.length; f += 1) {
    flip[f].outerHTML = ""; // Empty all elements in array
  }

  var framesPerSecond = 20;
  setInterval(updateAll, 1000/framesPerSecond); // Set the timer
  brickReset();// Initial Random Map

  function updateAll() { // General Functions
    
    resize(); // Check canvas size - if not a match resize
    moveAll(); // Apply movement to entities
    input(); // Poll for User Input
    drawAll(); // Update the screen
  }
 
  function moveAll() {
    ballX += ballSpeedX;
    ballY += ballSpeedY;

    if(ballX < 0 && ballSpeedX < 0.0) { // Left
      ballSpeedX *= -1;
    }

    if(ballX > canvas.width  && ballSpeedX > 0.0) { // Right
      ballSpeedX *= -1;
    }

    if(ballY < 0 && ballSpeedY < 0.0) { // Top
      ballSpeedY *= -1;
    }



    if(ballY > canvas.height) { // bottom
      ballReset(); // if goes off bottom, reset ball
      ballSpeedY *= -1; // Direction reversal
    }
   
    

    var paddleTopEdgeY = canvas.height - PADDLE_DIST_FROM_EDGE;
    var paddleBottomEdgeY = paddleTopEdgeY + PADDLE_THICKNESS;
    var paddleLeftEdgeX = paddleX;
    var paddleRightEdgeX = paddleLeftEdgeX + PADDLE_WIDTH;

    if (ballY > paddleTopEdgeY && // Below top of paddle
        ballY < paddleBottomEdgeY && // above the bottom
        ballX > paddleLeftEdgeX && // right of left side
        ballX < paddleRightEdgeX) { // left of right side
      ballSpeedY *= -1;

    var centerOfPaddleX = paddleX + PADDLE_WIDTH/2;
    var ballDistFromPaddleCenterX = ballX - centerOfPaddleX;
    ballSpeedX = ballDistFromPaddleCenterX * 0.35;

    if(bricksLeft === 0) {
      brickReset();
    }

    }






  }

  function drawAll() {
    colorRect(0,0, canvas.width,canvas.height, 'black'); // clear screen
    colorRect(paddleX, paddleY, PADDLE_WIDTH,PADDLE_THICKNESS, 'gold');// Draw Paddle
    drawBricks();
    //colorText(Math.floor(mouseX/scalex)+","+Math.floor(mouseY/scaley), mouseX/scalex,mouseY/scaley, 'yellow');// Draw Debug Paddle Text
    if (introtime <= 200) {
      colorTextFancy("Game of Life Demo under new link", 100,400);// Draw Debug Paddle Text
      introtime += 1;
    }
    colorTextFancy("Bricks "+bricksLeft, 10,20);// Draw Debug Paddle Text
    
    colorCircle(ballX,ballY, 5, "White"); // Draw the Ball
  }



  function isBrickAtColRow(col,row) {
    if(col >= 0 && col < BRICK_COLS &&
       row >= 0 && row < BRICK_ROWS) {
      var brickIndexUnderCoord = rowColToArrayIndex(col, row);
      return brickGrid[brickIndexUnderCoord];
    } else {
      return false;
    }
  }





  function input() {
    var ballBrickCol = Math.floor(ballX / BRICK_W); // Round values to save processor cycles
    var ballBrickRow = Math.floor(ballY / BRICK_H); // When computing scale(From resize function) of cursor position
    var brickIndexUnderBall = rowColToArrayIndex(ballBrickCol, ballBrickRow); // brickIndexUnderMouse is true if Index is matched
    
    if(ballBrickCol >= 0 && ballBrickCol < BRICK_COLS &&
       ballBrickRow >= 0 && ballBrickRow < BRICK_ROWS) { // And if so
      
      if(isBrickAtColRow(ballBrickCol,ballBrickRow)) {
        brickGrid[brickIndexUnderBall] = false; // Mark that square to be deleted
        bricksLeft--;


        var prevBallX = ballX - ballSpeedX;
        var prevBallY = ballY - ballSpeedY;
        var prevBrickCol = Math.floor(prevBallX / BRICK_W);
        var prevBrickRow = Math.floor(prevBallY / BRICK_H);

        var bothTestsFailed = true;

        if(prevBrickCol != ballBrickCol) {
          if(isBrickAtColRow(prevBrickCol, ballBrickRow) === false) {
            ballSpeedX *= -1;
            bothTestsFailed = false;
          }
          
        }
        if(prevBrickRow != ballBrickRow) {
          if(isBrickAtColRow(ballBrickCol, prevBrickRow) === false) {
            ballSpeedY *= -1;
            bothTestsFailed = false;
          }
          
        }

        if(bothTestsFailed) {
          ballSpeedX *= -1;
          ballSpeedY *= -1;
        }





        




      }
      
    }
  }

  function drawBricks() {
    for(eachRow=0;eachRow<BRICK_ROWS;eachRow += 1) { // For Each Column
      for(eachCol=0;eachCol<BRICK_COLS;eachCol += 1) { // And Each Row
        arrayIndex = rowColToArrayIndex(eachCol, eachRow); // Compute the Index
        if(brickGrid[arrayIndex]) { // And if that index reads true
          colorRect(BRICK_W*eachCol,BRICK_H*eachRow, BRICK_W-BRICK_GAP,BRICK_H-BRICK_GAP, gradient); // Draw a Blue square
        }
      }
    }
  }

  

  

  function updateMousePos(evt) {
    var rect = canvas.getBoundingClientRect(); // Get the size of the canvas
    var root = document.documentElement; // Get the document root from the DOM
    mouseX = evt.clientX - rect.left - root.scrollLeft; // Get the origin for the Left
    mouseY = evt.clientY - rect.top - root.scrollTop; // and top sides of the screen
    paddleX = mouseX / scalex - PADDLE_WIDTH/2; // Place the paddle on screen after factoring the scale
    // paddleY = mouseY / scaley - PADDLE_THICKNESS/2;
  }

  function brickReset() {
    bricksLeft = 0;
    for(i=0;i < 3*BRICK_COLS;i += 1) { // for all of the columns in all the rows
        brickGrid[i] = false;
    }
    for(;i<BRICK_COLS * BRICK_ROWS;i += 1) { // for all of the columns in all the rows
        brickGrid[i] = true;
        bricksLeft++;
    }
    ballReset();
  }

  function ballReset() {
    ballX = canvas.width/2;
    ballY = canvas.height/2;
  }

  function rowColToArrayIndex(col, row) { // calculate the index within the column array based on position
    return col + BRICK_COLS * row;
  }

  function colorRect(topLeftX,topLeftY, boxWidth,boxHeight, fillColor) { // General canvas Rectangle function
    canvasContext.fillStyle = fillColor;
    canvasContext.fillRect(topLeftX,topLeftY, boxWidth,boxHeight);
  }

  function colorCircle(centerX,centerY, radius, fillColor) { // General canvas Circle function
    canvasContext.fillStyle = fillColor;
    canvasContext.beginPath();
    canvasContext.arc(centerX,centerY, radius, 0,Math.PI*2, true);
    canvasContext.fill();
  }

  function colorText(showWords, textX,textY, fillColor) { // General canvas Text function
    canvasContext.fillStyle = fillColor;
    canvasContext.fillText(showWords, textX,textY);
  }

  function colorTextFancy(showWords, textX,textY) { // General canvas Text function
    canvasContext.font="20px Verdana";
    // Create gradient
    
    // Fill with gradient
    canvasContext.fillStyle=gradient;
    canvasContext.fillText(showWords, textX,textY);
  }








  function resize() { // resizes the canvas to the window width and height
    if (canvas.currentHeight !== window.innerHeight || canvas.currentWidth !== window.innerWidth) { // If we're not already perfectly sized for width and height
      canvas.currentHeight = window.innerHeight; // Size us with the height first
      ratio = window.innerWidth / window.innerHeight; // Then compute the aspect ratio of the window
      
      canvas.currentWidth = canvas.currentHeight * ratio; // And resize the width to that ratio
      scalex = canvas.currentWidth / canvas.width; // Our scale can now be computed based upon the original width
      scaley = canvas.currentHeight / canvas.width; // And height of the canvas vs it's new size, which we'll need for correct input
      canvas.style.width = canvas.currentWidth + 'px'; // scale the canvas with CSS
      canvas.style.height = canvas.currentHeight + 'px';
    }
  }

  function fullscreen(){ // Requests FullScreen from the browser on the first click
    if(filledscreen === false) { // If we haven't tried this before
     if(canvas.webkitRequestFullScreen) { // And if this is Chrome or Safari
         canvas.webkitRequestFullScreen(); // Go for the webkit fullscreen Request
     }
    else {
       canvas.mozRequestFullScreen(); // Else we'll try the Mozilla fullscreen Request
    }     
    filledscreen = true;  // Now we've tried this once.
    }              
  }

</script>